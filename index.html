<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#050510">
    <title>Neon Zen: Flow Link</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&display=swap');

        :root {
            --primary: #00f260;
            --secondary: #05c6ff;
            --danger: #ff2a2a;
            --dark: #050510;
            --glass: rgba(255, 255, 255, 0.08);
        }

        /* --- GLOBAL --- */
        body { 
            margin: 0; overflow: hidden; background-color: var(--dark); 
            font-family: 'Rajdhani', sans-serif; 
            touch-action: none; 
            user-select: none; 
            display: flex; justify-content: center; align-items: center; height: 100vh;
            color: white;
        }

        #app-container {
            width: 100%; max-width: 500px; height: 100%; max-height: 950px;
            position: relative; 
            background: radial-gradient(circle at center, #0a0a1f 0%, #000 100%);
            overflow: hidden; 
            box-shadow: 0 0 100px rgba(0, 242, 96, 0.1);
            transition: box-shadow 0.2s;
        }

        /* Heartbeat Effect */
        .heartbeat-mode { animation: heartbeat-panic 0.8s infinite; }
        @keyframes heartbeat-panic {
            0% { box-shadow: inset 0 0 0 var(--dark); border: 1px solid transparent; }
            50% { box-shadow: inset 0 0 100px rgba(255, 42, 42, 0.4); border: 2px solid var(--danger); }
            100% { box-shadow: inset 0 0 0 var(--dark); border: 1px solid transparent; }
        }

        /* --- CANVAS (Z-INDEX 1) --- */
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            touch-action: none; 
            /* Ensures crisp rendering on modern displays */
            image-rendering: -webkit-optimize-contrast; 
            image-rendering: crisp-edges;
        }

        /* --- UI LAYERS (Z-INDEX 10) --- */
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none; 
        }

        .layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            transition: opacity 0.5s;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(10px);
            opacity: 0;
            visibility: hidden; 
            pointer-events: none;
        }

        .layer.active { 
            opacity: 1; 
            visibility: visible; 
            pointer-events: auto; 
            background: transparent; 
        }
        
        .layer.static-bg { background: var(--dark); z-index: 500; } 

        /* --- LEVEL TRANSITION OVERLAY --- */
        #screen-transition {
            z-index: 600;
            background: var(--dark);
        }
        #transition-text {
            font-family: 'Orbitron';
            font-size: 3rem;
            color: var(--primary);
            text-shadow: 0 0 30px var(--primary);
            animation: zoomIn 1.5s ease-out forwards;
            text-align: center;
        }
        @keyframes zoomIn {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        /* --- LOADING --- */
        .logo-img { 
            width: 140px; height: 140px; border-radius: 20px; 
            object-fit: cover; box-shadow: 0 0 40px var(--primary); 
            margin-bottom: 20px; border: 2px solid white;
        }
        .company-name { font-family: 'Orbitron'; color: var(--primary); font-size: 1.2rem; letter-spacing: 3px; margin-bottom: 30px; }
        .loading-container { width: 80%; max-width: 300px; text-align: center; }
        .loading-bar-bg { width: 100%; height: 6px; background: #222; border-radius: 3px; overflow: hidden; margin-top: 10px; }
        .loading-bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--primary), var(--secondary)); transition: width 0.1s; }
        .loading-text { font-size: 0.8rem; color: #666; margin-top: 5px; }

        /* --- MENUS --- */
        .panel {
            background: rgba(10, 10, 25, 0.95);
            border: 1px solid var(--glass);
            padding: 30px; border-radius: 20px;
            width: 85%; text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            pointer-events: auto; 
        }

        h1 { font-family: 'Orbitron'; font-size: 2.5rem; margin: 0; background: linear-gradient(to right, #fff, var(--primary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        .menu-btn {
            display: block; width: 100%; margin: 12px 0; padding: 16px;
            border-radius: 12px; border: none;
            background: var(--glass); color: white; font-family: 'Rajdhani'; font-weight: 700;
            font-size: 1.1rem; cursor: pointer; transition: 0.1s;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: auto; 
        }
        .menu-btn:active { transform: scale(0.96); background: rgba(255,255,255,0.2); }
        .menu-btn.primary { background: var(--primary); color: #000; border: none; box-shadow: 0 0 20px rgba(0, 242, 96, 0.3); }

        /* --- HUD --- */
        #screen-hud { 
            justify-content: space-between; 
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 40%); 
            pointer-events: none; 
        }
        
        .hud-top { width: 100%; padding: 15px 20px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; }
        .stat-group { text-align: center; }
        .stat-val { font-family: 'Orbitron'; font-size: 1.4rem; font-weight: bold; color: white; text-shadow: 0 0 5px rgba(255,255,255,0.3); }
        .stat-label { font-size: 0.7rem; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }
        .target-val { color: var(--secondary); }
        .progress-wrap { width: 120px; height: 6px; background: #222; border-radius: 3px; margin-top: 5px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--secondary); width: 0%; transition: width 0.3s; }

        #combo-display { position: absolute; top: 120px; width: 100%; text-align: center; opacity: 0; transition: 0.2s; pointer-events: none; }
        #combo-text { font-family: 'Orbitron'; font-size: 4rem; color: var(--primary); text-shadow: 0 0 20px var(--primary); font-style: italic; }

        .hud-bottom { width: 100%; padding-bottom: 30px; display: flex; justify-content: center; gap: 15px; pointer-events: none; }
        .ctrl-btn {
            width: 60px; height: 60px; border-radius: 50%; background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2); color: white; font-size: 1.2rem;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px); transition: 0.2s; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            pointer-events: auto; 
        }
        .ctrl-btn:active { transform: scale(0.9); background: var(--primary); color: black; border-color: var(--primary); }
        .ctrl-btn.danger { border-color: var(--danger); color: var(--danger); }
        .ctrl-btn.danger:active { background: var(--danger); color: white; }

        /* --- FLOATING TEXT --- */
        .float-text { position: absolute; font-weight: bold; font-family: 'Orbitron'; pointer-events: none; animation: floatUp 1s forwards; text-shadow: 0 0 5px black; z-index: 100; }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-80px) scale(1.2); opacity: 0; } }

        /* --- LEVEL SELECT --- */
        .level-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; max-height: 300px; overflow-y: auto; width: 100%; padding: 10px; }
        .lvl-btn { background: #222; border: 1px solid #444; color: #666; padding: 10px; border-radius: 5px; cursor: pointer; font-family: 'Orbitron'; pointer-events: auto;}
        .lvl-btn.unlocked { color: white; background: #333; border-color: var(--primary); }
        .lvl-btn.current { background: var(--primary); color: black; box-shadow: 0 0 10px var(--primary); }

    </style>
</head>
<body>

<div id="app-container">
    
    <!-- CANVAS LAYER -->
    <canvas id="game-canvas"></canvas>

    <!-- UI LAYER -->
    <div id="ui-container">

        <!-- INIT SCREEN -->
        <div id="screen-init" class="layer active static-bg">
            <img src="assets/images/logo.jpeg" onerror="this.src='https://picsum.photos/seed/tuxtalk/150/150.jpg'" class="logo-img" alt="Logo">
            <div class="company-name">TUX-TALK GAMING</div>
            <button class="menu-btn primary" onclick="App.init()">TAP TO START</button>
        </div>

        <!-- LOADING SCREEN -->
        <div id="screen-loading" class="layer static-bg">
            <img src="assets/images/logo.jpeg" onerror="this.src='https://picsum.photos/seed/tuxtalk/150/150.jpg'" class="logo-img" alt="Logo">
            <div class="company-name">TUX-TALK GAMING</div>
            <div style="font-size:1.2rem; font-family:'Orbitron'; color:white;">INITIALIZING...</div>
            <div class="loading-container">
                <div class="loading-bar-bg"><div class="loading-bar-fill" id="load-bar"></div></div>
                <div class="loading-text" id="load-text">Loading Assets...</div>
            </div>
        </div>

        <!-- MAIN MENU -->
        <div id="screen-menu" class="layer">
            <div class="panel">
                <h1>NEON ZEN</h1>
                <p style="color: #888; margin-top: -10px; letter-spacing: 2px;">FLOW LINK</p>
                <div style="margin: 20px 0; display: flex; gap: 20px; justify-content: center; width: 100%;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.8rem; color: #aaa;">LEVEL</div>
                        <div style="font-size: 1.5rem; color: var(--primary); font-family: 'Orbitron';" id="menu-level">1</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.8rem; color: #aaa;">COINS</div>
                        <div style="font-size: 1.5rem; color: gold; font-family: 'Orbitron';"><i class="fas fa-coins"></i> <span id="menu-coins">0</span></div>
                    </div>
                </div>
                <button class="menu-btn primary" onclick="UI.showLevelSelect()"><i class="fas fa-play"></i> PLAY</button>
                <button class="menu-btn" onclick="UI.showShop()"><i class="fas fa-shopping-bag"></i> ITEM SHOP</button>
            </div>
        </div>

        <!-- LEVEL SELECT -->
        <div id="screen-levels" class="layer">
            <div class="panel">
                <h2>SELECT LEVEL</h2>
                <div class="level-grid" id="level-grid"></div>
                <button class="menu-btn" onclick="UI.showScreen('screen-menu')">BACK</button>
            </div>
        </div>

        <!-- SHOP -->
        <div id="screen-shop" class="layer">
            <div class="panel" style="height: 70%; display: flex; flex-direction: column;">
                <h2>ITEM SHOP</h2>
                <div style="color: gold; margin-bottom: 15px;"><i class="fas fa-coins"></i> <span id="shop-coins">0</span></div>
                <div id="shop-list" style="flex: 1; overflow-y: auto;"></div>
                <button class="menu-btn" onclick="UI.showScreen('screen-menu')">BACK</button>
            </div>
        </div>

        <!-- LEVEL TRANSITION ANIMATION -->
        <div id="screen-transition" class="layer static-bg hidden">
            <div id="transition-text">LEVEL 2</div>
        </div>

        <!-- GAME HUD -->
        <div id="screen-hud" class="layer active">
            <div class="hud-top">
                <div class="stat-group">
                    <div class="stat-label">Target</div>
                    <div class="stat-val target-val" id="hud-target">1000</div>
                    <div class="progress-wrap"><div class="progress-fill" id="hud-progress"></div></div>
                </div>
                <div class="stat-group">
                    <div class="stat-label">Moves</div>
                    <div class="stat-val" id="hud-moves">20</div>
                </div>
            </div>
            <div id="combo-display"><div id="combo-text">5x</div></div>
            <div class="hud-bottom">
                <div class="ctrl-btn" onclick="Game.activatePower('bomb')">
                    <i class="fas fa-bomb"></i>
                    <span style="position:absolute; bottom:-5px; right:-5px; background:#fff; color:#000; font-size:0.7rem; width:18px; height:18px; border-radius:50%; display:flex; align-items:center; justify-content:center;" id="badge-bomb">0</span>
                </div>
                <div class="ctrl-btn" onclick="Game.activatePower('life')">
                    <i class="fas fa-heart"></i>
                    <span style="position:absolute; bottom:-5px; right:-5px; background:#fff; color:#000; font-size:0.7rem; width:18px; height:18px; border-radius:50%; display:flex; align-items:center; justify-content:center;" id="badge-life">0</span>
                </div>
                <div class="ctrl-btn danger" onclick="Game.quitToMenu()"><i class="fas fa-home"></i></div>
            </div>
        </div>

        <!-- GAME OVER / PAUSE -->
        <div id="screen-msg" class="layer">
            <div class="panel">
                <h2 id="msg-title">PAUSED</h2>
                <p id="msg-desc" style="color:#ccc;">...</p>
                <button class="menu-btn primary" id="msg-btn-1" onclick="Game.resume()">RESUME</button>
                <button class="menu-btn" onclick="Game.quitToMenu()">MAIN MENU</button>
            </div>
        </div>

    </div> 
</div> 

<script>
/* ----------------------------------------------------------------
   1. AUDIO SYSTEM
   ---------------------------------------------------------------- */
const AudioSys = {
    ctx: null,
    init: function() {
        if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    
    playBoot: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator(), gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(50, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 1);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime); gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1.2);
        osc.start(); osc.stop(this.ctx.currentTime + 1.5);
    },

    playLoading: function() {
        if (!this.ctx) return;
        [261, 329, 392, 523, 659, 783].forEach((freq, i) => {
            const osc = this.ctx.createOscillator(), gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'sine'; osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.05, this.ctx.currentTime + i*0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + i*0.1 + 0.3);
            osc.start(this.ctx.currentTime + i*0.1); osc.stop(this.ctx.currentTime + i*0.1 + 0.4);
        });
    },

    playMatch: function(chainLen) {
        if (!this.ctx) return;
        const baseFreqs = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25];
        const freq = baseFreqs[(chainLen - 3) % baseFreqs.length];
        const osc = this.ctx.createOscillator(), gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'triangle'; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        osc.start(); osc.stop(this.ctx.currentTime + 0.4);
    },

    playWin: function() {
        if (!this.ctx) return;
        [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => {
            const osc = this.ctx.createOscillator(), gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.type = 'square'; osc.frequency.value = f;
            gain.gain.setValueAtTime(0.05, this.ctx.currentTime + i*0.1);
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + i*0.1 + 0.5);
            osc.start(this.ctx.currentTime + i*0.1); osc.stop(this.ctx.currentTime + i*0.1 + 0.6);
        });
    },

    playLevelUp: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator(), gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(261.63, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(523.25, this.ctx.currentTime + 0.5);
        osc.frequency.linearRampToValueAtTime(1046.50, this.ctx.currentTime + 1.0);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1.5);
        osc.start(); osc.stop(this.ctx.currentTime + 1.6);
    },

    playLose: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator(), gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 1);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime); gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
        osc.start(); osc.stop(this.ctx.currentTime + 1.2);
    },

    playPower: function() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator(), gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'sine'; osc.frequency.setValueAtTime(800, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime); gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        osc.start(); osc.stop(this.ctx.currentTime + 0.4);
    }
};

/* ----------------------------------------------------------------
   2. DATA
   ---------------------------------------------------------------- */
const Data = {
    coins: 0, currentLevel: 1, unlockedLevel: 1,
    inventory: { bomb: 1, life: 1 },
    save: function() { localStorage.setItem('nz_v5_data', JSON.stringify(this)); },
    load: function() { const s = localStorage.getItem('nz_v5_data'); if(s) Object.assign(this, JSON.parse(s)); }
};

const LevelManager = {
    getLevel: function(lvl) {
        let shape = 'square';
        // CLEAN & BRIGHT PALETTES
        let palette = ['#FF3333', '#33FF57', '#3357FF', '#F1C40F', '#8E44AD']; 
        
        if(lvl > 20 && lvl <= 40) { shape = 'circle'; palette = ['#E74C3C', '#2ECC71', '#3498DB', '#F1C40F', '#9B59B6']; }
        if(lvl > 40 && lvl <= 60) { shape = 'diamond'; palette = ['#E67E22', '#1ABC9C', '#2980B9', '#D35400', '#7F8C8D']; }
        if(lvl > 60 && lvl <= 80) { shape = 'hex'; palette = ['#F39C12', '#16A085', '#2C3E50', '#C0392B', '#27AE60']; }
        if(lvl > 80) { shape = 'star'; palette = ['#FF00FF', '#00FFFF', '#FFFF00', '#FF0055', '#00FF00']; }
        
        return { target: 500 + (lvl * 250), moves: Math.max(10, 30 - Math.floor(lvl / 5)), shape, colors: palette };
    }
};

/* ----------------------------------------------------------------
   3. GAME ENGINE
   ---------------------------------------------------------------- */
const Game = {
    canvas: document.getElementById('game-canvas'),
    ctx: document.getElementById('game-canvas').getContext('2d'),
    grid: [], particles: [], chain: [], state: 'MENU', levelData: null,
    score: 0, moves: 0, target: 0, isDragging: false,
    width: 0, height: 0, blockSize: 0, offsetX: 0, offsetY: 0,

    init: function() {
        this.resize(); 
        window.addEventListener('resize', () => this.resize());
        
        // FIX: CRISP RENDERING
        this.ctx.imageSmoothingEnabled = false;
        
        const getPos = (e) => {
            let cx, cy;
            if(e.touches && e.touches.length > 0) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; } 
            else { cx = e.clientX; cy = e.clientY; }
            return {x: cx, y: cy};
        };

        const start = (e) => { if(e.target === this.canvas) e.preventDefault(); const p = getPos(e); this.inputStart(p.x, p.y); };
        const move = (e) => { if(e.target === this.canvas) e.preventDefault(); const p = getPos(e); this.inputMove(p.x, p.y); };
        const end = (e) => { this.inputEnd(); };

        this.canvas.addEventListener('mousedown', start);
        this.canvas.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        this.canvas.addEventListener('touchstart', start, {passive: false});
        this.canvas.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('touchend', end);

        Data.load();
        this.loop();
    },

    resize: function() {
        const container = document.getElementById('app-container');
        this.width = container.clientWidth;
        this.height = container.clientHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        const margin = 20;
        this.blockSize = Math.floor((this.width - margin * 2) / 6);
        this.offsetX = margin;
        this.offsetY = (this.height * 0.2);
        // Re-apply crisp setting on resize
        this.ctx.imageSmoothingEnabled = false;
    },

    startLevel: function(lvl) {
        Data.currentLevel = lvl; this.levelData = LevelManager.getLevel(lvl);
        this.score = 0; this.moves = this.levelData.moves; this.target = this.levelData.target;
        this.state = 'PLAY'; this.chain = []; this.grid = [];
        
        const rows = Math.floor((this.height - this.offsetY - 100) / this.blockSize);
        for(let r=0; r<rows; r++) {
            for(let c=0; c<6; c++) {
                this.grid.push({
                    r, c, x: this.offsetX + c * this.blockSize, y: this.offsetY + r * this.blockSize,
                    color: this.levelData.colors[Math.floor(Math.random() * this.levelData.colors.length)],
                    active: true, scale: 0, highlight: 0,
                    breatheOffset: Math.random() * 100 
                });
            }
        }
        UI.updateHUD();
        UI.showScreen('screen-hud');
        document.getElementById('app-container').classList.remove('heartbeat-mode');
    },

    inputStart: function(clientX, clientY) {
        if(this.state !== 'PLAY') return;
        const rect = this.canvas.getBoundingClientRect();
        if (rect.width === 0) return;
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        const x = (clientX - rect.left) * scaleX;
        const y = (clientY - rect.top) * scaleY;

        const b = this.getBlockAt(x, y);
        if(b && b.active) { this.isDragging = true; this.chain = [b]; this.triggerFeedback(b); }
    },

    inputMove: function(clientX, clientY) {
        if(!this.isDragging) return;
        const rect = this.canvas.getBoundingClientRect();
        if (rect.width === 0) return;
        const scaleX = this.canvas.width / rect.width;
        const scaleY = this.canvas.height / rect.height;
        const x = (clientX - rect.left) * scaleX;
        const y = (clientY - rect.top) * scaleY;

        const b = this.getBlockAt(x, y);
        const last = this.chain[this.chain.length-1];
        if(b && b !== last && b.active) {
            const dist = Math.abs(b.r - last.r) + Math.abs(b.c - last.c);
            if(dist === 1 && b.color === last.color && !this.chain.includes(b)) { this.chain.push(b); this.triggerFeedback(b); }
            else if (this.chain.length > 1 && b === this.chain[this.chain.length-2]) { this.chain.pop(); }
        }
    },

    inputEnd: function() {
        if(!this.isDragging) return;
        this.isDragging = false;
        if(this.chain.length >= 3) { this.processMatch(); } 
        else { this.chain.forEach(b => b.highlight = 0); this.chain = []; }
    },

    getBlockAt: function(x, y) {
        return this.grid.find(b => b.active && x >= b.x && x < b.x + this.blockSize && y >= b.y && y < b.y + this.blockSize);
    },

    triggerFeedback: function(block) {
        block.highlight = 1; AudioSys.playMatch(this.chain.length);
        if(navigator.vibrate) navigator.vibrate(5);
        this.spawnParticles(block.x + this.blockSize/2, block.y + this.blockSize/2, block.color, 2);
    },

    processMatch: function() {
        const count = this.chain.length;
        const points = count * 10 * count; this.score += points; this.moves--;
        
        const comboEl = document.getElementById('combo-display'), comboTxt = document.getElementById('combo-text');
        comboTxt.innerText = count + "x"; comboEl.style.opacity = 1; comboEl.style.transform = "scale(1.2)";
        setTimeout(() => { comboEl.style.opacity = 0; comboEl.style.transform = "scale(1)"; }, 800);
        
        UI.showFloatText(`+${points}`, this.chain[this.chain.length-1].x, this.chain[this.chain.length-1].y);
        this.chain.forEach(b => { b.active = false; this.spawnParticles(b.x + this.blockSize/2, b.y + this.blockSize/2, b.color, 8); b.highlight = 0; });
        this.chain = []; UI.updateHUD();
        setTimeout(() => this.refill(), 300);
    },

    refill: function() {
        for(let c=0; c<6; c++) {
            const activeBlocks = this.grid.filter(b => b.c === c && b.active).sort((a,b) => b.r - a.r);
            const totalRows = Math.floor((this.height - this.offsetY - 100) / this.blockSize);
            this.grid = this.grid.filter(b => b.c !== c);
            for(let i=0; i<activeBlocks.length; i++) {
                const b = activeBlocks[i]; b.r = totalRows - 1 - i; b.y = this.offsetY + b.r * this.blockSize; this.grid.push(b);
            }
            for(let i=0; i < (totalRows - activeBlocks.length); i++) {
                const r = (totalRows - activeBlocks.length) - 1 - i;
                this.grid.push({ r, c, x: this.offsetX + c * this.blockSize, y: - (i * 60) - 100, color: this.levelData.colors[Math.floor(Math.random() * this.levelData.colors.length)], active: true, scale: 0, highlight: 0, breatheOffset: Math.random()*100 });
            }
        }
        this.checkState();
    },

    checkState: function() {
        const container = document.getElementById('app-container');
        if(this.moves <= 3) container.classList.add('heartbeat-mode'); else container.classList.remove('heartbeat-mode');
        if(this.score >= this.target) { this.transitionToNextLevel(); } 
        else if (this.moves <= 0) { this.loseLevel(); }
    },

    transitionToNextLevel: function() {
        this.state = 'TRANSITION';
        const nextLvl = Data.currentLevel + 1;
        AudioSys.playLevelUp();
        const reward = Math.floor(this.target / 10) + (Data.currentLevel * 10);
        Data.coins += reward;
        if(Data.currentLevel >= Data.unlockedLevel && Data.currentLevel < 100) { Data.unlockedLevel = Data.currentLevel + 1; }
        Data.save();

        const transitionScreen = document.getElementById('screen-transition');
        const transitionText = document.getElementById('transition-text');
        transitionText.innerText = "LEVEL " + nextLvl;
        
        document.getElementById('screen-hud').classList.remove('active');
        
        transitionScreen.classList.remove('hidden');
        transitionScreen.classList.add('active');

        setTimeout(() => {
            transitionScreen.classList.remove('active');
            transitionScreen.classList.add('hidden');
            if(nextLvl <= 100) {
                this.startLevel(nextLvl);
            } else {
                alert("YOU WIN! ALL 100 LEVELS COMPLETE!");
                this.quitToMenu();
            }
        }, 2000);
    },

    loseLevel: function() {
        this.state = 'END'; AudioSys.playLose();
        document.getElementById('msg-title').innerText = "OUT OF MOVES"; document.getElementById('msg-title').style.color = "var(--danger)";
        document.getElementById('msg-desc').innerText = "Target not reached.";
        document.getElementById('msg-btn-1').innerText = "RETRY"; document.getElementById('msg-btn-1').onclick = () => this.startLevel(Data.currentLevel);
        UI.showScreen('screen-msg');
    },

    activatePower: function(type) {
        if(Data.inventory[type] > 0) {
            if(type === 'bomb') {
                const center = this.grid[Math.floor(Math.random()*this.grid.length)];
                this.grid.forEach(b => { const d = Math.abs(b.r - center.r) + Math.abs(b.c - center.c); if(d <= 2 && b.active) { b.active = false; this.spawnParticles(b.x, b.y, b.color, 5); } });
                setTimeout(() => this.refill(), 500);
            }
            if(type === 'life') { this.moves += 5; UI.updateHUD(); UI.showFloatText("+5 MOVES", this.width/2, this.height/2); }
            Data.inventory[type]--; AudioSys.playPower(); UI.updateHUD();
        } else { UI.showFloatText("NO ITEM", this.width/2, this.height/2); }
    },

    quitToMenu: function() { this.state = 'MENU'; UI.showMenu(); },
    resume: function() { this.state = 'PLAY'; UI.showScreen('screen-hud'); },

    spawnParticles: function(x, y, color, count) {
        for(let i=0; i<count; i++) { this.particles.push({ x, y, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 1, color }); }
    },

    loop: function() {
        requestAnimationFrame(() => this.loop());
        const ctx = this.ctx; const w = this.width; const h = this.height; ctx.clearRect(0,0,w,h);
        
        // Force crisp rendering every frame (safeguard)
        ctx.imageSmoothingEnabled = false;

        const time = Date.now() / 500;

        if(this.chain.length > 0) {
            ctx.beginPath(); ctx.strokeStyle = 'white'; ctx.lineWidth = 8; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            // Add glow ONLY to the line, not blocks
            ctx.shadowColor = 'rgba(255,255,255,0.5)';
            ctx.shadowBlur = 10;

            const start = this.chain[0]; ctx.moveTo(start.x + this.blockSize/2, start.y + this.blockSize/2);
            for(let i=1; i<this.chain.length; i++) {
                const b = this.chain[i]; const prev = this.chain[i-1]; const mx = (prev.x + b.x)/2 + this.blockSize/2; const my = (prev.y + b.y)/2 + this.blockSize/2;
                ctx.quadraticCurveTo(prev.x + this.blockSize/2, prev.y + this.blockSize/2, mx, my);
            }
            const last = this.chain[this.chain.length-1]; ctx.lineTo(last.x + this.blockSize/2, last.y + this.blockSize/2); ctx.stroke();
            
            // Reset shadow for blocks
            ctx.shadowBlur = 0;
        }
        
        this.grid.forEach(b => {
            b.y += (this.offsetY + b.r * this.blockSize - b.y) * 0.2;
            if(b.scale < 1) b.scale += (1 - b.scale) * 0.2;
            if(!b.active) b.scale *= 0.8;
            if(b.scale < 0.01) return;

            const cx = b.x + this.blockSize/2;
            const cy = b.y + this.blockSize/2;
            
            let breathing = Math.sin(time + b.breatheOffset) * 1.0; // Reduced amplitude for crispness
            if(this.moves <= 3) { breathing *= 2.0; }

            // Round coordinates to integer pixels to prevent sub-pixel blur
            const size = Math.round((this.blockSize - 6) * b.scale / 2 + breathing);
            const rcx = Math.round(cx);
            const rcy = Math.round(cy);

            ctx.fillStyle = b.color; 
            
            // Outer White Border (Crisp)
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.lineJoin = 'miter'; // Sharp corners

            // Highlight border
            if(b.highlight > 0) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 5;
            }

            ctx.beginPath(); const s = this.levelData ? this.levelData.shape : 'square';
            
            if(s === 'square') { ctx.roundRect(rcx - size, rcy - size, size*2, size*2, 8); } 
            else if(s === 'circle') { ctx.arc(rcx, rcy, size, 0, Math.PI*2); } 
            else if(s === 'diamond') { ctx.moveTo(rcx, rcy - size); ctx.lineTo(rcx + size, rcy); ctx.lineTo(rcx, rcy + size); ctx.lineTo(rcx - size, rcy); ctx.closePath(); } 
            else if(s === 'hex') { for(let i=0; i<6; i++) { const angle = (Math.PI/3) * i; const hx = rcx + size * Math.cos(angle); const hy = rcy + size * Math.sin(angle); if(i===0) ctx.moveTo(hx, hy); else ctx.lineTo(hx, hy); } ctx.closePath(); } 
            else if(s === 'star') { for(let i=0; i<5; i++) { ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*size + rcx, -Math.sin((18+i*72)/180*Math.PI)*size + rcy); ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*size/2 + rcx, -Math.sin((54+i*72)/180*Math.PI)*size/2 + rcy); } ctx.closePath(); }
            
            ctx.fill();
            ctx.stroke(); // Draw sharp border
        });
        
        // Particles
        for(let i=this.particles.length-1; i>=0; i--) {
            let p = this.particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            if(p.life <= 0) { this.particles.splice(i,1); continue; }
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();
        } ctx.globalAlpha = 1;
    }
};

/* ----------------------------------------------------------------
   4. UI CONTROLLER
   ---------------------------------------------------------------- */
const UI = {
    showScreen: function(id) {
        document.querySelectorAll('.layer').forEach(l => { l.classList.remove('active'); });
        const el = document.getElementById(id);
        if(id === 'screen-hud') { el.classList.add('active'); } 
        else { el.classList.add('active'); }
        if(id === 'screen-menu') this.updateMenu();
    },
    showMenu: function() { this.showScreen('screen-menu'); },
    showLevelSelect: function() {
        const grid = document.getElementById('level-grid'); grid.innerHTML = '';
        for(let i=1; i<=100; i++) {
            const btn = document.createElement('div'); btn.className = 'lvl-btn'; btn.innerText = i;
            if(i <= Data.unlockedLevel) {
                btn.classList.add('unlocked'); if(i === Data.unlockedLevel) btn.classList.add('current');
                btn.onclick = () => { Game.startLevel(i); };
            }
            grid.appendChild(btn);
        } this.showScreen('screen-levels');
    },
    showShop: function() {
        const list = document.getElementById('shop-list'); list.innerHTML = '';
        document.getElementById('shop-coins').innerText = Data.coins;
        const items = [ { id: 'bomb', name: 'Area Bomb', cost: 200, icon: 'fa-bomb' }, { id: 'life', name: '+5 Moves', cost: 100, icon: 'fa-heart' } ];
        items.forEach(item => {
            const el = document.createElement('div'); el.className = 'menu-btn'; el.style.display = 'flex'; el.style.justifyContent = 'space-between';
            el.innerHTML = `<span><i class="fas ${item.icon}"></i> ${item.name}</span> <span style="color:gold">${item.cost}</span>`;
            el.onclick = () => {
                if(Data.coins >= item.cost) { Data.coins -= item.cost; Data.inventory[item.id]++; Data.save(); this.showShop(); App.toast("Purchased!"); }
                else { App.toast("Need more coins"); }
            }; list.appendChild(el);
        }); this.showScreen('screen-shop');
    },
    updateHUD: function() {
        document.getElementById('hud-target').innerText = Game.target;
        document.getElementById('hud-moves').innerText = Game.moves;
        const pct = Math.min(100, (Game.score / Game.target) * 100);
        document.getElementById('hud-progress').style.width = pct + "%";
        document.getElementById('badge-bomb').innerText = Data.inventory.bomb;
        document.getElementById('badge-life').innerText = Data.inventory.life;
    },
    updateMenu: function() {
        document.getElementById('menu-level').innerText = Data.currentLevel;
        document.getElementById('menu-coins').innerText = Data.coins;
    },
    showFloatText: function(txt, x, y) {
        const el = document.createElement('div'); el.className = 'float-text'; el.innerText = txt;
        el.style.left = x + 'px'; el.style.top = y + 'px'; document.body.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }
};

/* ----------------------------------------------------------------
   5. APP ORCHESTRATOR
   ---------------------------------------------------------------- */
const App = {
    init: function() {
        AudioSys.init(); AudioSys.playBoot();
        UI.showScreen('screen-loading');
        const bar = document.getElementById('load-bar'), txt = document.getElementById('load-text');
        let w = 0;
        const steps = [ { p: 30, t: "Loading Assets..." }, { p: 60, t: "Generating 100 Levels..." }, { p: 90, t: "Tuning Audio..." }, { p: 100, t: "Ready!" } ];
        let stepIdx = 0;
        const interval = setInterval(() => {
            w += 1; bar.style.width = w + "%";
            if(stepIdx < steps.length && w >= steps[stepIdx].p) { txt.innerText = steps[stepIdx].t; stepIdx++; }
            if(w >= 100) {
                clearInterval(interval); AudioSys.playLoading();
                setTimeout(() => { UI.showMenu(); }, 1000);
            }
        }, 20);
    },
    toast: function(msg) {
        const el = document.createElement('div'); el.style.position = 'absolute'; el.style.top = '20px'; el.style.left = '50%'; el.style.transform = 'translateX(-50%)'; el.style.background = 'white'; el.style.color = 'black'; el.style.padding = '10px 20px'; el.style.borderRadius = '20px'; el.style.zIndex = '1000'; el.innerText = msg; document.body.appendChild(el); setTimeout(() => el.remove(), 2000);
    }
};

// Start
Game.init();

// PWA Service Worker
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        if (location.protocol.startsWith('http')) {
            navigator.serviceWorker.register('./service-worker.js').then(() => console.log('SW Registered')).catch(err => console.log('SW Fail:', err));
        } else { console.log("Skipping SW: Running locally."); }
    });
}
</script>
</body>
</html>